// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: FunctionRpc.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

/// protobuf vscode extension: https://marketplace.visualstudio.com/items?itemName=zxh404.vscode-proto3

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct AzureFunctionsRpcMessages_StreamingMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Used to identify message between host and worker
  var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Payload of the message
  var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  /// Worker initiates stream
  var startStream: AzureFunctionsRpcMessages_StartStream {
    get {
      if case .startStream(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_StartStream()
    }
    set {_uniqueStorage()._content = .startStream(newValue)}
  }

  /// Host sends capabilities/init data to worker
  var workerInitRequest: AzureFunctionsRpcMessages_WorkerInitRequest {
    get {
      if case .workerInitRequest(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_WorkerInitRequest()
    }
    set {_uniqueStorage()._content = .workerInitRequest(newValue)}
  }

  /// Worker responds after initializing with its capabilities & status
  var workerInitResponse: AzureFunctionsRpcMessages_WorkerInitResponse {
    get {
      if case .workerInitResponse(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_WorkerInitResponse()
    }
    set {_uniqueStorage()._content = .workerInitResponse(newValue)}
  }

  /// Worker periodically sends empty heartbeat message to host
  var workerHeartbeat: AzureFunctionsRpcMessages_WorkerHeartbeat {
    get {
      if case .workerHeartbeat(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_WorkerHeartbeat()
    }
    set {_uniqueStorage()._content = .workerHeartbeat(newValue)}
  }

  /// Host sends terminate message to worker.
  /// Worker terminates if it can, otherwise host terminates after a grace period
  var workerTerminate: AzureFunctionsRpcMessages_WorkerTerminate {
    get {
      if case .workerTerminate(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_WorkerTerminate()
    }
    set {_uniqueStorage()._content = .workerTerminate(newValue)}
  }

  /// Add any worker relevant status to response
  var workerStatusRequest: AzureFunctionsRpcMessages_WorkerStatusRequest {
    get {
      if case .workerStatusRequest(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_WorkerStatusRequest()
    }
    set {_uniqueStorage()._content = .workerStatusRequest(newValue)}
  }

  var workerStatusResponse: AzureFunctionsRpcMessages_WorkerStatusResponse {
    get {
      if case .workerStatusResponse(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_WorkerStatusResponse()
    }
    set {_uniqueStorage()._content = .workerStatusResponse(newValue)}
  }

  /// On file change event, host sends notification to worker
  var fileChangeEventRequest: AzureFunctionsRpcMessages_FileChangeEventRequest {
    get {
      if case .fileChangeEventRequest(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_FileChangeEventRequest()
    }
    set {_uniqueStorage()._content = .fileChangeEventRequest(newValue)}
  }

  /// Worker requests a desired action (restart worker, reload function)
  var workerActionResponse: AzureFunctionsRpcMessages_WorkerActionResponse {
    get {
      if case .workerActionResponse(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_WorkerActionResponse()
    }
    set {_uniqueStorage()._content = .workerActionResponse(newValue)}
  }

  /// Host sends required metadata to worker to load function
  var functionLoadRequest: AzureFunctionsRpcMessages_FunctionLoadRequest {
    get {
      if case .functionLoadRequest(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_FunctionLoadRequest()
    }
    set {_uniqueStorage()._content = .functionLoadRequest(newValue)}
  }

  /// Worker responds after loading with the load result
  var functionLoadResponse: AzureFunctionsRpcMessages_FunctionLoadResponse {
    get {
      if case .functionLoadResponse(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_FunctionLoadResponse()
    }
    set {_uniqueStorage()._content = .functionLoadResponse(newValue)}
  }

  /// Host requests a given invocation
  var invocationRequest: AzureFunctionsRpcMessages_InvocationRequest {
    get {
      if case .invocationRequest(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_InvocationRequest()
    }
    set {_uniqueStorage()._content = .invocationRequest(newValue)}
  }

  /// Worker responds to a given invocation
  var invocationResponse: AzureFunctionsRpcMessages_InvocationResponse {
    get {
      if case .invocationResponse(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_InvocationResponse()
    }
    set {_uniqueStorage()._content = .invocationResponse(newValue)}
  }

  /// Host sends cancel message to attempt to cancel an invocation. 
  /// If an invocation is cancelled, host will receive an invocation response with status cancelled.
  var invocationCancel: AzureFunctionsRpcMessages_InvocationCancel {
    get {
      if case .invocationCancel(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_InvocationCancel()
    }
    set {_uniqueStorage()._content = .invocationCancel(newValue)}
  }

  /// Worker logs a message back to the host
  var rpcLog: AzureFunctionsRpcMessages_RpcLog {
    get {
      if case .rpcLog(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_RpcLog()
    }
    set {_uniqueStorage()._content = .rpcLog(newValue)}
  }

  var functionEnvironmentReloadRequest: AzureFunctionsRpcMessages_FunctionEnvironmentReloadRequest {
    get {
      if case .functionEnvironmentReloadRequest(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_FunctionEnvironmentReloadRequest()
    }
    set {_uniqueStorage()._content = .functionEnvironmentReloadRequest(newValue)}
  }

  var functionEnvironmentReloadResponse: AzureFunctionsRpcMessages_FunctionEnvironmentReloadResponse {
    get {
      if case .functionEnvironmentReloadResponse(let v)? = _storage._content {return v}
      return AzureFunctionsRpcMessages_FunctionEnvironmentReloadResponse()
    }
    set {_uniqueStorage()._content = .functionEnvironmentReloadResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Payload of the message
  enum OneOf_Content: Equatable {
    /// Worker initiates stream
    case startStream(AzureFunctionsRpcMessages_StartStream)
    /// Host sends capabilities/init data to worker
    case workerInitRequest(AzureFunctionsRpcMessages_WorkerInitRequest)
    /// Worker responds after initializing with its capabilities & status
    case workerInitResponse(AzureFunctionsRpcMessages_WorkerInitResponse)
    /// Worker periodically sends empty heartbeat message to host
    case workerHeartbeat(AzureFunctionsRpcMessages_WorkerHeartbeat)
    /// Host sends terminate message to worker.
    /// Worker terminates if it can, otherwise host terminates after a grace period
    case workerTerminate(AzureFunctionsRpcMessages_WorkerTerminate)
    /// Add any worker relevant status to response
    case workerStatusRequest(AzureFunctionsRpcMessages_WorkerStatusRequest)
    case workerStatusResponse(AzureFunctionsRpcMessages_WorkerStatusResponse)
    /// On file change event, host sends notification to worker
    case fileChangeEventRequest(AzureFunctionsRpcMessages_FileChangeEventRequest)
    /// Worker requests a desired action (restart worker, reload function)
    case workerActionResponse(AzureFunctionsRpcMessages_WorkerActionResponse)
    /// Host sends required metadata to worker to load function
    case functionLoadRequest(AzureFunctionsRpcMessages_FunctionLoadRequest)
    /// Worker responds after loading with the load result
    case functionLoadResponse(AzureFunctionsRpcMessages_FunctionLoadResponse)
    /// Host requests a given invocation
    case invocationRequest(AzureFunctionsRpcMessages_InvocationRequest)
    /// Worker responds to a given invocation
    case invocationResponse(AzureFunctionsRpcMessages_InvocationResponse)
    /// Host sends cancel message to attempt to cancel an invocation. 
    /// If an invocation is cancelled, host will receive an invocation response with status cancelled.
    case invocationCancel(AzureFunctionsRpcMessages_InvocationCancel)
    /// Worker logs a message back to the host
    case rpcLog(AzureFunctionsRpcMessages_RpcLog)
    case functionEnvironmentReloadRequest(AzureFunctionsRpcMessages_FunctionEnvironmentReloadRequest)
    case functionEnvironmentReloadResponse(AzureFunctionsRpcMessages_FunctionEnvironmentReloadResponse)

  #if !swift(>=4.1)
    static func ==(lhs: AzureFunctionsRpcMessages_StreamingMessage.OneOf_Content, rhs: AzureFunctionsRpcMessages_StreamingMessage.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.startStream(let l), .startStream(let r)): return l == r
      case (.workerInitRequest(let l), .workerInitRequest(let r)): return l == r
      case (.workerInitResponse(let l), .workerInitResponse(let r)): return l == r
      case (.workerHeartbeat(let l), .workerHeartbeat(let r)): return l == r
      case (.workerTerminate(let l), .workerTerminate(let r)): return l == r
      case (.workerStatusRequest(let l), .workerStatusRequest(let r)): return l == r
      case (.workerStatusResponse(let l), .workerStatusResponse(let r)): return l == r
      case (.fileChangeEventRequest(let l), .fileChangeEventRequest(let r)): return l == r
      case (.workerActionResponse(let l), .workerActionResponse(let r)): return l == r
      case (.functionLoadRequest(let l), .functionLoadRequest(let r)): return l == r
      case (.functionLoadResponse(let l), .functionLoadResponse(let r)): return l == r
      case (.invocationRequest(let l), .invocationRequest(let r)): return l == r
      case (.invocationResponse(let l), .invocationResponse(let r)): return l == r
      case (.invocationCancel(let l), .invocationCancel(let r)): return l == r
      case (.rpcLog(let l), .rpcLog(let r)): return l == r
      case (.functionEnvironmentReloadRequest(let l), .functionEnvironmentReloadRequest(let r)): return l == r
      case (.functionEnvironmentReloadResponse(let l), .functionEnvironmentReloadResponse(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Worker sends the host information identifying itself
struct AzureFunctionsRpcMessages_StartStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the worker
  var workerID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Host requests the worker to initialize itself 
struct AzureFunctionsRpcMessages_WorkerInitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// version of the host sending init request
  var hostVersion: String = String()

  /// A map of host supported features/capabilities
  var capabilities: Dictionary<String,String> = [:]

  /// inform worker of supported categories and their levels
  /// i.e. Worker = Verbose, Function.MyFunc = None
  var logCategories: Dictionary<String,AzureFunctionsRpcMessages_RpcLog.Level> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Worker responds with the result of initializing itself
struct AzureFunctionsRpcMessages_WorkerInitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of worker
  var workerVersion: String {
    get {return _storage._workerVersion}
    set {_uniqueStorage()._workerVersion = newValue}
  }

  /// A map of worker supported features/capabilities
  var capabilities: Dictionary<String,String> {
    get {return _storage._capabilities}
    set {_uniqueStorage()._capabilities = newValue}
  }

  /// Status of the response
  var result: AzureFunctionsRpcMessages_StatusResult {
    get {return _storage._result ?? AzureFunctionsRpcMessages_StatusResult()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {_uniqueStorage()._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Used by the host to determine success/failure/cancellation
struct AzureFunctionsRpcMessages_StatusResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status for the given result
  var status: AzureFunctionsRpcMessages_StatusResult.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Specific message about the result
  var result: String {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  /// Exception message (if exists) for the status
  var exception: AzureFunctionsRpcMessages_RpcException {
    get {return _storage._exception ?? AzureFunctionsRpcMessages_RpcException()}
    set {_uniqueStorage()._exception = newValue}
  }
  /// Returns true if `exception` has been explicitly set.
  var hasException: Bool {return _storage._exception != nil}
  /// Clears the value of `exception`. Subsequent reads from it will return its default value.
  mutating func clearException() {_uniqueStorage()._exception = nil}

  /// Captured logs or relevant details can use the logs property
  var logs: [AzureFunctionsRpcMessages_RpcLog] {
    get {return _storage._logs}
    set {_uniqueStorage()._logs = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates Failure/Success/Cancelled
  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case failure // = 0
    case success // = 1
    case cancelled // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .failure
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .failure
      case 1: self = .success
      case 2: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .failure: return 0
      case .success: return 1
      case .cancelled: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension AzureFunctionsRpcMessages_StatusResult.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [AzureFunctionsRpcMessages_StatusResult.Status] = [
    .failure,
    .success,
    .cancelled,
  ]
}

#endif  // swift(>=4.2)

/// Message is empty by design - Will add more fields in future if needed
struct AzureFunctionsRpcMessages_WorkerHeartbeat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Warning before killing the process after grace_period
/// Worker self terminates ..no response on this
struct AzureFunctionsRpcMessages_WorkerTerminate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gracePeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._gracePeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._gracePeriod = newValue}
  }
  /// Returns true if `gracePeriod` has been explicitly set.
  var hasGracePeriod: Bool {return _storage._gracePeriod != nil}
  /// Clears the value of `gracePeriod`. Subsequent reads from it will return its default value.
  mutating func clearGracePeriod() {_uniqueStorage()._gracePeriod = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Host notifies worker of file content change
struct AzureFunctionsRpcMessages_FileChangeEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// type for this event
  var type: AzureFunctionsRpcMessages_FileChangeEventRequest.TypeEnum = .unknown

  /// full file path for the file change notification
  var fullPath: String = String()

  /// Name of the function affected
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Types of File change operations (See link for more info: https://msdn.microsoft.com/en-us/library/t6xf43e0(v=vs.110).aspx)
  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case created // = 1
    case deleted // = 2
    case changed // = 4
    case renamed // = 8
    case all // = 15
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .created
      case 2: self = .deleted
      case 4: self = .changed
      case 8: self = .renamed
      case 15: self = .all
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .created: return 1
      case .deleted: return 2
      case .changed: return 4
      case .renamed: return 8
      case .all: return 15
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension AzureFunctionsRpcMessages_FileChangeEventRequest.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [AzureFunctionsRpcMessages_FileChangeEventRequest.TypeEnum] = [
    .unknown,
    .created,
    .deleted,
    .changed,
    .renamed,
    .all,
  ]
}

#endif  // swift(>=4.2)

/// Indicates whether worker reloaded successfully or needs a restart
struct AzureFunctionsRpcMessages_WorkerActionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// action for this response
  var action: AzureFunctionsRpcMessages_WorkerActionResponse.Action = .restart

  /// text reason for the response
  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// indicates whether a restart is needed, or reload succesfully
  enum Action: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case restart // = 0
    case reload // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .restart
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .restart
      case 1: self = .reload
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .restart: return 0
      case .reload: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension AzureFunctionsRpcMessages_WorkerActionResponse.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [AzureFunctionsRpcMessages_WorkerActionResponse.Action] = [
    .restart,
    .reload,
  ]
}

#endif  // swift(>=4.2)

/// NOT USED
struct AzureFunctionsRpcMessages_WorkerStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NOT USED
struct AzureFunctionsRpcMessages_WorkerStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AzureFunctionsRpcMessages_FunctionEnvironmentReloadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Environment variables from the current process
  var environmentVariables: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AzureFunctionsRpcMessages_FunctionEnvironmentReloadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the response
  var result: AzureFunctionsRpcMessages_StatusResult {
    get {return _storage._result ?? AzureFunctionsRpcMessages_StatusResult()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {_uniqueStorage()._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Host tells the worker to load a Function
struct AzureFunctionsRpcMessages_FunctionLoadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique function identifier (avoid name collisions, facilitate reload case)
  var functionID: String {
    get {return _storage._functionID}
    set {_uniqueStorage()._functionID = newValue}
  }

  /// Metadata for the request
  var metadata: AzureFunctionsRpcMessages_RpcFunctionMetadata {
    get {return _storage._metadata ?? AzureFunctionsRpcMessages_RpcFunctionMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// A flag indicating if managed dependency is enabled or not
  var managedDependencyEnabled: Bool {
    get {return _storage._managedDependencyEnabled}
    set {_uniqueStorage()._managedDependencyEnabled = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Worker tells host result of reload
struct AzureFunctionsRpcMessages_FunctionLoadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique function identifier
  var functionID: String {
    get {return _storage._functionID}
    set {_uniqueStorage()._functionID = newValue}
  }

  /// Result of load operation
  var result: AzureFunctionsRpcMessages_StatusResult {
    get {return _storage._result ?? AzureFunctionsRpcMessages_StatusResult()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {_uniqueStorage()._result = nil}

  /// Result of load operation
  var isDependencyDownloaded: Bool {
    get {return _storage._isDependencyDownloaded}
    set {_uniqueStorage()._isDependencyDownloaded = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Information on how a Function should be loaded and its bindings
struct AzureFunctionsRpcMessages_RpcFunctionMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: do we want the host's name - the language worker might do a better job of assignment than the host
  var name: String = String()

  /// base directory for the Function
  var directory: String = String()

  /// Script file specified
  var scriptFile: String = String()

  /// Entry point specified
  var entryPoint: String = String()

  /// Bindings info
  var bindings: Dictionary<String,AzureFunctionsRpcMessages_BindingInfo> = [:]

  /// Is set to true for proxy
  var isProxy: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Host requests worker to invoke a Function
struct AzureFunctionsRpcMessages_InvocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique id for each invocation
  var invocationID: String = String()

  /// Unique id for each Function
  var functionID: String = String()

  /// Input bindings (include trigger)
  var inputData: [AzureFunctionsRpcMessages_ParameterBinding] = []

  /// binding metadata from trigger
  var triggerMetadata: Dictionary<String,AzureFunctionsRpcMessages_TypedData> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Host requests worker to cancel invocation
struct AzureFunctionsRpcMessages_InvocationCancel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique id for invocation
  var invocationID: String {
    get {return _storage._invocationID}
    set {_uniqueStorage()._invocationID = newValue}
  }

  /// Time period before force shutdown
  var gracePeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._gracePeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._gracePeriod = newValue}
  }
  /// Returns true if `gracePeriod` has been explicitly set.
  var hasGracePeriod: Bool {return _storage._gracePeriod != nil}
  /// Clears the value of `gracePeriod`. Subsequent reads from it will return its default value.
  mutating func clearGracePeriod() {_uniqueStorage()._gracePeriod = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Worker responds with status of Invocation
struct AzureFunctionsRpcMessages_InvocationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique id for invocation
  var invocationID: String {
    get {return _storage._invocationID}
    set {_uniqueStorage()._invocationID = newValue}
  }

  /// Output binding data
  var outputData: [AzureFunctionsRpcMessages_ParameterBinding] {
    get {return _storage._outputData}
    set {_uniqueStorage()._outputData = newValue}
  }

  /// data returned from Function (for $return and triggers with return support)
  var returnValue: AzureFunctionsRpcMessages_TypedData {
    get {return _storage._returnValue ?? AzureFunctionsRpcMessages_TypedData()}
    set {_uniqueStorage()._returnValue = newValue}
  }
  /// Returns true if `returnValue` has been explicitly set.
  var hasReturnValue: Bool {return _storage._returnValue != nil}
  /// Clears the value of `returnValue`. Subsequent reads from it will return its default value.
  mutating func clearReturnValue() {_uniqueStorage()._returnValue = nil}

  /// Status of the invocation (success/failure/canceled)
  var result: AzureFunctionsRpcMessages_StatusResult {
    get {return _storage._result ?? AzureFunctionsRpcMessages_StatusResult()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {_uniqueStorage()._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Used to encapsulate data which could be a variety of types
struct AzureFunctionsRpcMessages_TypedData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var string: String {
    get {
      if case .string(let v)? = _storage._data {return v}
      return String()
    }
    set {_uniqueStorage()._data = .string(newValue)}
  }

  var json: String {
    get {
      if case .json(let v)? = _storage._data {return v}
      return String()
    }
    set {_uniqueStorage()._data = .json(newValue)}
  }

  var bytes: Data {
    get {
      if case .bytes(let v)? = _storage._data {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._data = .bytes(newValue)}
  }

  var stream: Data {
    get {
      if case .stream(let v)? = _storage._data {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._data = .stream(newValue)}
  }

  var http: AzureFunctionsRpcMessages_RpcHttp {
    get {
      if case .http(let v)? = _storage._data {return v}
      return AzureFunctionsRpcMessages_RpcHttp()
    }
    set {_uniqueStorage()._data = .http(newValue)}
  }

  var int: Int64 {
    get {
      if case .int(let v)? = _storage._data {return v}
      return 0
    }
    set {_uniqueStorage()._data = .int(newValue)}
  }

  var double: Double {
    get {
      if case .double(let v)? = _storage._data {return v}
      return 0
    }
    set {_uniqueStorage()._data = .double(newValue)}
  }

  var collectionBytes: AzureFunctionsRpcMessages_CollectionBytes {
    get {
      if case .collectionBytes(let v)? = _storage._data {return v}
      return AzureFunctionsRpcMessages_CollectionBytes()
    }
    set {_uniqueStorage()._data = .collectionBytes(newValue)}
  }

  var collectionString: AzureFunctionsRpcMessages_CollectionString {
    get {
      if case .collectionString(let v)? = _storage._data {return v}
      return AzureFunctionsRpcMessages_CollectionString()
    }
    set {_uniqueStorage()._data = .collectionString(newValue)}
  }

  var collectionDouble: AzureFunctionsRpcMessages_CollectionDouble {
    get {
      if case .collectionDouble(let v)? = _storage._data {return v}
      return AzureFunctionsRpcMessages_CollectionDouble()
    }
    set {_uniqueStorage()._data = .collectionDouble(newValue)}
  }

  var collectionSint64: AzureFunctionsRpcMessages_CollectionSInt64 {
    get {
      if case .collectionSint64(let v)? = _storage._data {return v}
      return AzureFunctionsRpcMessages_CollectionSInt64()
    }
    set {_uniqueStorage()._data = .collectionSint64(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case string(String)
    case json(String)
    case bytes(Data)
    case stream(Data)
    case http(AzureFunctionsRpcMessages_RpcHttp)
    case int(Int64)
    case double(Double)
    case collectionBytes(AzureFunctionsRpcMessages_CollectionBytes)
    case collectionString(AzureFunctionsRpcMessages_CollectionString)
    case collectionDouble(AzureFunctionsRpcMessages_CollectionDouble)
    case collectionSint64(AzureFunctionsRpcMessages_CollectionSInt64)

  #if !swift(>=4.1)
    static func ==(lhs: AzureFunctionsRpcMessages_TypedData.OneOf_Data, rhs: AzureFunctionsRpcMessages_TypedData.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.string(let l), .string(let r)): return l == r
      case (.json(let l), .json(let r)): return l == r
      case (.bytes(let l), .bytes(let r)): return l == r
      case (.stream(let l), .stream(let r)): return l == r
      case (.http(let l), .http(let r)): return l == r
      case (.int(let l), .int(let r)): return l == r
      case (.double(let l), .double(let r)): return l == r
      case (.collectionBytes(let l), .collectionBytes(let r)): return l == r
      case (.collectionString(let l), .collectionString(let r)): return l == r
      case (.collectionDouble(let l), .collectionDouble(let r)): return l == r
      case (.collectionSint64(let l), .collectionSint64(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Used to encapsulate collection string
struct AzureFunctionsRpcMessages_CollectionString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var string: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used to encapsulate collection bytes
struct AzureFunctionsRpcMessages_CollectionBytes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bytes: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used to encapsulate collection double
struct AzureFunctionsRpcMessages_CollectionDouble {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var double: [Double] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used to encapsulate collection sint64
struct AzureFunctionsRpcMessages_CollectionSInt64 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sint64: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used to describe a given binding on invocation
struct AzureFunctionsRpcMessages_ParameterBinding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name for the binding
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Data for the binding
  var data: AzureFunctionsRpcMessages_TypedData {
    get {return _storage._data ?? AzureFunctionsRpcMessages_TypedData()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {_uniqueStorage()._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Used to describe a given binding on load
struct AzureFunctionsRpcMessages_BindingInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of binding (e.g. HttpTrigger)
  var type: String = String()

  /// Direction of the given binding
  var direction: AzureFunctionsRpcMessages_BindingInfo.Direction = .in

  var dataType: AzureFunctionsRpcMessages_BindingInfo.DataType = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates whether it is an input or output binding (or a fancy inout binding)
  enum Direction: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `in` // = 0
    case out // = 1
    case `inout` // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .in
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .in
      case 1: self = .out
      case 2: self = .inout
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .in: return 0
      case .out: return 1
      case .inout: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Indicates the type of the data for the binding
  enum DataType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case undefined // = 0
    case string // = 1
    case binary // = 2
    case stream // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .string
      case 2: self = .binary
      case 3: self = .stream
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .string: return 1
      case .binary: return 2
      case .stream: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension AzureFunctionsRpcMessages_BindingInfo.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [AzureFunctionsRpcMessages_BindingInfo.Direction] = [
    .in,
    .out,
    .inout,
  ]
}

extension AzureFunctionsRpcMessages_BindingInfo.DataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [AzureFunctionsRpcMessages_BindingInfo.DataType] = [
    .undefined,
    .string,
    .binary,
    .stream,
  ]
}

#endif  // swift(>=4.2)

/// Used to send logs back to the Host 
struct AzureFunctionsRpcMessages_RpcLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique id for invocation (if exists)
  var invocationID: String {
    get {return _storage._invocationID}
    set {_uniqueStorage()._invocationID = newValue}
  }

  /// TOD: This should be an enum
  /// Category for the log (startup, load, invocation, etc.)
  var category: String {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  /// Level for the given log message
  var level: AzureFunctionsRpcMessages_RpcLog.Level {
    get {return _storage._level}
    set {_uniqueStorage()._level = newValue}
  }

  /// Message for the given log
  var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// Id for the even associated with this log (if exists)
  var eventID: String {
    get {return _storage._eventID}
    set {_uniqueStorage()._eventID = newValue}
  }

  /// Exception (if exists)
  var exception: AzureFunctionsRpcMessages_RpcException {
    get {return _storage._exception ?? AzureFunctionsRpcMessages_RpcException()}
    set {_uniqueStorage()._exception = newValue}
  }
  /// Returns true if `exception` has been explicitly set.
  var hasException: Bool {return _storage._exception != nil}
  /// Clears the value of `exception`. Subsequent reads from it will return its default value.
  mutating func clearException() {_uniqueStorage()._exception = nil}

  /// json serialized property bag, or could use a type scheme like map<string, TypedData>
  var properties: String {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Matching ILogger semantics
  /// https://github.com/aspnet/Logging/blob/9506ccc3f3491488fe88010ef8b9eb64594abf95/src/Microsoft.Extensions.Logging/Logger.cs
  /// Level for the Log
  enum Level: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case trace // = 0
    case debug // = 1
    case information // = 2
    case warning // = 3
    case error // = 4
    case critical // = 5
    case none // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .trace
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .trace
      case 1: self = .debug
      case 2: self = .information
      case 3: self = .warning
      case 4: self = .error
      case 5: self = .critical
      case 6: self = .none
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .trace: return 0
      case .debug: return 1
      case .information: return 2
      case .warning: return 3
      case .error: return 4
      case .critical: return 5
      case .none: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension AzureFunctionsRpcMessages_RpcLog.Level: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [AzureFunctionsRpcMessages_RpcLog.Level] = [
    .trace,
    .debug,
    .information,
    .warning,
    .error,
    .critical,
    .none,
  ]
}

#endif  // swift(>=4.2)

/// Encapsulates an Exception 
struct AzureFunctionsRpcMessages_RpcException {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Source of the exception
  var source: String = String()

  /// Stack trace for the exception
  var stackTrace: String = String()

  /// Textual message describing hte exception
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Http cookie type. Note that only name and value are used for Http requests
struct AzureFunctionsRpcMessages_RpcHttpCookie {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cookie name
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Cookie value
  var value: String {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// Specifies allowed hosts to receive the cookie
  var domain: AzureFunctionsRpcMessages_NullableString {
    get {return _storage._domain ?? AzureFunctionsRpcMessages_NullableString()}
    set {_uniqueStorage()._domain = newValue}
  }
  /// Returns true if `domain` has been explicitly set.
  var hasDomain: Bool {return _storage._domain != nil}
  /// Clears the value of `domain`. Subsequent reads from it will return its default value.
  mutating func clearDomain() {_uniqueStorage()._domain = nil}

  /// Specifies URL path that must exist in the requested URL
  var path: AzureFunctionsRpcMessages_NullableString {
    get {return _storage._path ?? AzureFunctionsRpcMessages_NullableString()}
    set {_uniqueStorage()._path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return _storage._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {_uniqueStorage()._path = nil}

  /// Sets the cookie to expire at a specific date instead of when the client closes.
  /// It is generally recommended that you use "Max-Age" over "Expires".
  var expires: AzureFunctionsRpcMessages_NullableTimestamp {
    get {return _storage._expires ?? AzureFunctionsRpcMessages_NullableTimestamp()}
    set {_uniqueStorage()._expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return _storage._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {_uniqueStorage()._expires = nil}

  /// Sets the cookie to only be sent with an encrypted request
  var secure: AzureFunctionsRpcMessages_NullableBool {
    get {return _storage._secure ?? AzureFunctionsRpcMessages_NullableBool()}
    set {_uniqueStorage()._secure = newValue}
  }
  /// Returns true if `secure` has been explicitly set.
  var hasSecure: Bool {return _storage._secure != nil}
  /// Clears the value of `secure`. Subsequent reads from it will return its default value.
  mutating func clearSecure() {_uniqueStorage()._secure = nil}

  /// Sets the cookie to be inaccessible to JavaScript's Document.cookie API
  var httpOnly: AzureFunctionsRpcMessages_NullableBool {
    get {return _storage._httpOnly ?? AzureFunctionsRpcMessages_NullableBool()}
    set {_uniqueStorage()._httpOnly = newValue}
  }
  /// Returns true if `httpOnly` has been explicitly set.
  var hasHTTPOnly: Bool {return _storage._httpOnly != nil}
  /// Clears the value of `httpOnly`. Subsequent reads from it will return its default value.
  mutating func clearHTTPOnly() {_uniqueStorage()._httpOnly = nil}

  /// Allows servers to assert that a cookie ought not to be sent along with cross-site requests
  var sameSite: AzureFunctionsRpcMessages_RpcHttpCookie.SameSite {
    get {return _storage._sameSite}
    set {_uniqueStorage()._sameSite = newValue}
  }

  /// Number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately.
  var maxAge: AzureFunctionsRpcMessages_NullableDouble {
    get {return _storage._maxAge ?? AzureFunctionsRpcMessages_NullableDouble()}
    set {_uniqueStorage()._maxAge = newValue}
  }
  /// Returns true if `maxAge` has been explicitly set.
  var hasMaxAge: Bool {return _storage._maxAge != nil}
  /// Clears the value of `maxAge`. Subsequent reads from it will return its default value.
  mutating func clearMaxAge() {_uniqueStorage()._maxAge = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enum that lets servers require that a cookie shouoldn't be sent with cross-site requests
  enum SameSite: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case lax // = 1
    case strict // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .lax
      case 2: self = .strict
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .lax: return 1
      case .strict: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension AzureFunctionsRpcMessages_RpcHttpCookie.SameSite: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [AzureFunctionsRpcMessages_RpcHttpCookie.SameSite] = [
    .none,
    .lax,
    .strict,
  ]
}

#endif  // swift(>=4.2)

/// TODO - solidify this or remove it
struct AzureFunctionsRpcMessages_RpcHttp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var method: String {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  var headers: Dictionary<String,String> {
    get {return _storage._headers}
    set {_uniqueStorage()._headers = newValue}
  }

  var body: AzureFunctionsRpcMessages_TypedData {
    get {return _storage._body ?? AzureFunctionsRpcMessages_TypedData()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  var params: Dictionary<String,String> {
    get {return _storage._params}
    set {_uniqueStorage()._params = newValue}
  }

  var statusCode: String {
    get {return _storage._statusCode}
    set {_uniqueStorage()._statusCode = newValue}
  }

  var query: Dictionary<String,String> {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  var enableContentNegotiation: Bool {
    get {return _storage._enableContentNegotiation}
    set {_uniqueStorage()._enableContentNegotiation = newValue}
  }

  var rawBody: AzureFunctionsRpcMessages_TypedData {
    get {return _storage._rawBody ?? AzureFunctionsRpcMessages_TypedData()}
    set {_uniqueStorage()._rawBody = newValue}
  }
  /// Returns true if `rawBody` has been explicitly set.
  var hasRawBody: Bool {return _storage._rawBody != nil}
  /// Clears the value of `rawBody`. Subsequent reads from it will return its default value.
  mutating func clearRawBody() {_uniqueStorage()._rawBody = nil}

  var identities: [AzureFunctionsRpcMessages_RpcClaimsIdentity] {
    get {return _storage._identities}
    set {_uniqueStorage()._identities = newValue}
  }

  var cookies: [AzureFunctionsRpcMessages_RpcHttpCookie] {
    get {return _storage._cookies}
    set {_uniqueStorage()._cookies = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "AzureFunctionsRpcMessages"

extension AzureFunctionsRpcMessages_StreamingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    20: .standard(proto: "start_stream"),
    17: .standard(proto: "worker_init_request"),
    16: .standard(proto: "worker_init_response"),
    15: .standard(proto: "worker_heartbeat"),
    14: .standard(proto: "worker_terminate"),
    12: .standard(proto: "worker_status_request"),
    13: .standard(proto: "worker_status_response"),
    6: .standard(proto: "file_change_event_request"),
    7: .standard(proto: "worker_action_response"),
    8: .standard(proto: "function_load_request"),
    9: .standard(proto: "function_load_response"),
    4: .standard(proto: "invocation_request"),
    5: .standard(proto: "invocation_response"),
    21: .standard(proto: "invocation_cancel"),
    2: .standard(proto: "rpc_log"),
    25: .standard(proto: "function_environment_reload_request"),
    26: .standard(proto: "function_environment_reload_response"),
  ]

  fileprivate class _StorageClass {
    var _requestID: String = String()
    var _content: AzureFunctionsRpcMessages_StreamingMessage.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requestID = source._requestID
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._requestID)
        case 2:
          var v: AzureFunctionsRpcMessages_RpcLog?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .rpcLog(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .rpcLog(v)}
        case 4:
          var v: AzureFunctionsRpcMessages_InvocationRequest?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .invocationRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .invocationRequest(v)}
        case 5:
          var v: AzureFunctionsRpcMessages_InvocationResponse?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .invocationResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .invocationResponse(v)}
        case 6:
          var v: AzureFunctionsRpcMessages_FileChangeEventRequest?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .fileChangeEventRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .fileChangeEventRequest(v)}
        case 7:
          var v: AzureFunctionsRpcMessages_WorkerActionResponse?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .workerActionResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .workerActionResponse(v)}
        case 8:
          var v: AzureFunctionsRpcMessages_FunctionLoadRequest?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .functionLoadRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .functionLoadRequest(v)}
        case 9:
          var v: AzureFunctionsRpcMessages_FunctionLoadResponse?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .functionLoadResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .functionLoadResponse(v)}
        case 12:
          var v: AzureFunctionsRpcMessages_WorkerStatusRequest?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .workerStatusRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .workerStatusRequest(v)}
        case 13:
          var v: AzureFunctionsRpcMessages_WorkerStatusResponse?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .workerStatusResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .workerStatusResponse(v)}
        case 14:
          var v: AzureFunctionsRpcMessages_WorkerTerminate?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .workerTerminate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .workerTerminate(v)}
        case 15:
          var v: AzureFunctionsRpcMessages_WorkerHeartbeat?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .workerHeartbeat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .workerHeartbeat(v)}
        case 16:
          var v: AzureFunctionsRpcMessages_WorkerInitResponse?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .workerInitResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .workerInitResponse(v)}
        case 17:
          var v: AzureFunctionsRpcMessages_WorkerInitRequest?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .workerInitRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .workerInitRequest(v)}
        case 20:
          var v: AzureFunctionsRpcMessages_StartStream?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .startStream(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .startStream(v)}
        case 21:
          var v: AzureFunctionsRpcMessages_InvocationCancel?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .invocationCancel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .invocationCancel(v)}
        case 25:
          var v: AzureFunctionsRpcMessages_FunctionEnvironmentReloadRequest?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .functionEnvironmentReloadRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .functionEnvironmentReloadRequest(v)}
        case 26:
          var v: AzureFunctionsRpcMessages_FunctionEnvironmentReloadResponse?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .functionEnvironmentReloadResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .functionEnvironmentReloadResponse(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 1)
      }
      switch _storage._content {
      case .rpcLog(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .invocationRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .invocationResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .fileChangeEventRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .workerActionResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .functionLoadRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .functionLoadResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .workerStatusRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .workerStatusResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .workerTerminate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .workerHeartbeat(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .workerInitResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .workerInitRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .startStream(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .invocationCancel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .functionEnvironmentReloadRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .functionEnvironmentReloadResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_StreamingMessage, rhs: AzureFunctionsRpcMessages_StreamingMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_StartStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartStream"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "worker_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularStringField(value: &self.workerID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workerID.isEmpty {
      try visitor.visitSingularStringField(value: self.workerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_StartStream, rhs: AzureFunctionsRpcMessages_StartStream) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_WorkerInitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorkerInitRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "host_version"),
    2: .same(proto: "capabilities"),
    3: .standard(proto: "log_categories"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hostVersion)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.capabilities)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,AzureFunctionsRpcMessages_RpcLog.Level>.self, value: &self.logCategories)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.hostVersion, fieldNumber: 1)
    }
    if !self.capabilities.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.capabilities, fieldNumber: 2)
    }
    if !self.logCategories.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,AzureFunctionsRpcMessages_RpcLog.Level>.self, value: self.logCategories, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_WorkerInitRequest, rhs: AzureFunctionsRpcMessages_WorkerInitRequest) -> Bool {
    if lhs.hostVersion != rhs.hostVersion {return false}
    if lhs.capabilities != rhs.capabilities {return false}
    if lhs.logCategories != rhs.logCategories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_WorkerInitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorkerInitResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_version"),
    2: .same(proto: "capabilities"),
    3: .same(proto: "result"),
  ]

  fileprivate class _StorageClass {
    var _workerVersion: String = String()
    var _capabilities: Dictionary<String,String> = [:]
    var _result: AzureFunctionsRpcMessages_StatusResult? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workerVersion = source._workerVersion
      _capabilities = source._capabilities
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._workerVersion)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._capabilities)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._result)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._workerVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workerVersion, fieldNumber: 1)
      }
      if !_storage._capabilities.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._capabilities, fieldNumber: 2)
      }
      if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_WorkerInitResponse, rhs: AzureFunctionsRpcMessages_WorkerInitResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workerVersion != rhs_storage._workerVersion {return false}
        if _storage._capabilities != rhs_storage._capabilities {return false}
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_StatusResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "status"),
    1: .same(proto: "result"),
    2: .same(proto: "exception"),
    3: .same(proto: "logs"),
  ]

  fileprivate class _StorageClass {
    var _status: AzureFunctionsRpcMessages_StatusResult.Status = .failure
    var _result: String = String()
    var _exception: AzureFunctionsRpcMessages_RpcException? = nil
    var _logs: [AzureFunctionsRpcMessages_RpcLog] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _result = source._result
      _exception = source._exception
      _logs = source._logs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._result)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._exception)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._logs)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._result.isEmpty {
        try visitor.visitSingularStringField(value: _storage._result, fieldNumber: 1)
      }
      if let v = _storage._exception {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._logs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._logs, fieldNumber: 3)
      }
      if _storage._status != .failure {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_StatusResult, rhs: AzureFunctionsRpcMessages_StatusResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._exception != rhs_storage._exception {return false}
        if _storage._logs != rhs_storage._logs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_StatusResult.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Failure"),
    1: .same(proto: "Success"),
    2: .same(proto: "Cancelled"),
  ]
}

extension AzureFunctionsRpcMessages_WorkerHeartbeat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorkerHeartbeat"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_WorkerHeartbeat, rhs: AzureFunctionsRpcMessages_WorkerHeartbeat) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_WorkerTerminate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorkerTerminate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "grace_period"),
  ]

  fileprivate class _StorageClass {
    var _gracePeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gracePeriod = source._gracePeriod
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._gracePeriod)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gracePeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_WorkerTerminate, rhs: AzureFunctionsRpcMessages_WorkerTerminate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gracePeriod != rhs_storage._gracePeriod {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_FileChangeEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileChangeEventRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "full_path"),
    3: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.fullPath)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.fullPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fullPath, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_FileChangeEventRequest, rhs: AzureFunctionsRpcMessages_FileChangeEventRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.fullPath != rhs.fullPath {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_FileChangeEventRequest.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "Created"),
    2: .same(proto: "Deleted"),
    4: .same(proto: "Changed"),
    8: .same(proto: "Renamed"),
    15: .same(proto: "All"),
  ]
}

extension AzureFunctionsRpcMessages_WorkerActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorkerActionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.action)
      case 2: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .restart {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_WorkerActionResponse, rhs: AzureFunctionsRpcMessages_WorkerActionResponse) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_WorkerActionResponse.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Restart"),
    1: .same(proto: "Reload"),
  ]
}

extension AzureFunctionsRpcMessages_WorkerStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorkerStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_WorkerStatusRequest, rhs: AzureFunctionsRpcMessages_WorkerStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_WorkerStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorkerStatusResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_WorkerStatusResponse, rhs: AzureFunctionsRpcMessages_WorkerStatusResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_FunctionEnvironmentReloadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionEnvironmentReloadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "environment_variables"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.environmentVariables)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.environmentVariables.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.environmentVariables, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_FunctionEnvironmentReloadRequest, rhs: AzureFunctionsRpcMessages_FunctionEnvironmentReloadRequest) -> Bool {
    if lhs.environmentVariables != rhs.environmentVariables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_FunctionEnvironmentReloadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionEnvironmentReloadResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "result"),
  ]

  fileprivate class _StorageClass {
    var _result: AzureFunctionsRpcMessages_StatusResult? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 3: try decoder.decodeSingularMessageField(value: &_storage._result)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_FunctionEnvironmentReloadResponse, rhs: AzureFunctionsRpcMessages_FunctionEnvironmentReloadResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_FunctionLoadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionLoadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_id"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "managed_dependency_enabled"),
  ]

  fileprivate class _StorageClass {
    var _functionID: String = String()
    var _metadata: AzureFunctionsRpcMessages_RpcFunctionMetadata? = nil
    var _managedDependencyEnabled: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _functionID = source._functionID
      _metadata = source._metadata
      _managedDependencyEnabled = source._managedDependencyEnabled
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._functionID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._managedDependencyEnabled)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._functionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._functionID, fieldNumber: 1)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._managedDependencyEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._managedDependencyEnabled, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_FunctionLoadRequest, rhs: AzureFunctionsRpcMessages_FunctionLoadRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._functionID != rhs_storage._functionID {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._managedDependencyEnabled != rhs_storage._managedDependencyEnabled {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_FunctionLoadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionLoadResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_id"),
    2: .same(proto: "result"),
    3: .standard(proto: "is_dependency_downloaded"),
  ]

  fileprivate class _StorageClass {
    var _functionID: String = String()
    var _result: AzureFunctionsRpcMessages_StatusResult? = nil
    var _isDependencyDownloaded: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _functionID = source._functionID
      _result = source._result
      _isDependencyDownloaded = source._isDependencyDownloaded
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._functionID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._result)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._isDependencyDownloaded)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._functionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._functionID, fieldNumber: 1)
      }
      if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._isDependencyDownloaded != false {
        try visitor.visitSingularBoolField(value: _storage._isDependencyDownloaded, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_FunctionLoadResponse, rhs: AzureFunctionsRpcMessages_FunctionLoadResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._functionID != rhs_storage._functionID {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._isDependencyDownloaded != rhs_storage._isDependencyDownloaded {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_RpcFunctionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcFunctionMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "name"),
    1: .same(proto: "directory"),
    2: .standard(proto: "script_file"),
    3: .standard(proto: "entry_point"),
    6: .same(proto: "bindings"),
    7: .standard(proto: "is_proxy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.directory)
      case 2: try decoder.decodeSingularStringField(value: &self.scriptFile)
      case 3: try decoder.decodeSingularStringField(value: &self.entryPoint)
      case 4: try decoder.decodeSingularStringField(value: &self.name)
      case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,AzureFunctionsRpcMessages_BindingInfo>.self, value: &self.bindings)
      case 7: try decoder.decodeSingularBoolField(value: &self.isProxy)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.directory.isEmpty {
      try visitor.visitSingularStringField(value: self.directory, fieldNumber: 1)
    }
    if !self.scriptFile.isEmpty {
      try visitor.visitSingularStringField(value: self.scriptFile, fieldNumber: 2)
    }
    if !self.entryPoint.isEmpty {
      try visitor.visitSingularStringField(value: self.entryPoint, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.bindings.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,AzureFunctionsRpcMessages_BindingInfo>.self, value: self.bindings, fieldNumber: 6)
    }
    if self.isProxy != false {
      try visitor.visitSingularBoolField(value: self.isProxy, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_RpcFunctionMetadata, rhs: AzureFunctionsRpcMessages_RpcFunctionMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.directory != rhs.directory {return false}
    if lhs.scriptFile != rhs.scriptFile {return false}
    if lhs.entryPoint != rhs.entryPoint {return false}
    if lhs.bindings != rhs.bindings {return false}
    if lhs.isProxy != rhs.isProxy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_InvocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvocationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invocation_id"),
    2: .standard(proto: "function_id"),
    3: .standard(proto: "input_data"),
    4: .standard(proto: "trigger_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.invocationID)
      case 2: try decoder.decodeSingularStringField(value: &self.functionID)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.inputData)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,AzureFunctionsRpcMessages_TypedData>.self, value: &self.triggerMetadata)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invocationID.isEmpty {
      try visitor.visitSingularStringField(value: self.invocationID, fieldNumber: 1)
    }
    if !self.functionID.isEmpty {
      try visitor.visitSingularStringField(value: self.functionID, fieldNumber: 2)
    }
    if !self.inputData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputData, fieldNumber: 3)
    }
    if !self.triggerMetadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,AzureFunctionsRpcMessages_TypedData>.self, value: self.triggerMetadata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_InvocationRequest, rhs: AzureFunctionsRpcMessages_InvocationRequest) -> Bool {
    if lhs.invocationID != rhs.invocationID {return false}
    if lhs.functionID != rhs.functionID {return false}
    if lhs.inputData != rhs.inputData {return false}
    if lhs.triggerMetadata != rhs.triggerMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_InvocationCancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvocationCancel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "invocation_id"),
    1: .standard(proto: "grace_period"),
  ]

  fileprivate class _StorageClass {
    var _invocationID: String = String()
    var _gracePeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _invocationID = source._invocationID
      _gracePeriod = source._gracePeriod
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._gracePeriod)
        case 2: try decoder.decodeSingularStringField(value: &_storage._invocationID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gracePeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._invocationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._invocationID, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_InvocationCancel, rhs: AzureFunctionsRpcMessages_InvocationCancel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._invocationID != rhs_storage._invocationID {return false}
        if _storage._gracePeriod != rhs_storage._gracePeriod {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_InvocationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvocationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invocation_id"),
    2: .standard(proto: "output_data"),
    4: .standard(proto: "return_value"),
    3: .same(proto: "result"),
  ]

  fileprivate class _StorageClass {
    var _invocationID: String = String()
    var _outputData: [AzureFunctionsRpcMessages_ParameterBinding] = []
    var _returnValue: AzureFunctionsRpcMessages_TypedData? = nil
    var _result: AzureFunctionsRpcMessages_StatusResult? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _invocationID = source._invocationID
      _outputData = source._outputData
      _returnValue = source._returnValue
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._invocationID)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._outputData)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._result)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._returnValue)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._invocationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._invocationID, fieldNumber: 1)
      }
      if !_storage._outputData.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._outputData, fieldNumber: 2)
      }
      if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._returnValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_InvocationResponse, rhs: AzureFunctionsRpcMessages_InvocationResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._invocationID != rhs_storage._invocationID {return false}
        if _storage._outputData != rhs_storage._outputData {return false}
        if _storage._returnValue != rhs_storage._returnValue {return false}
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_TypedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypedData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "string"),
    2: .same(proto: "json"),
    3: .same(proto: "bytes"),
    4: .same(proto: "stream"),
    5: .same(proto: "http"),
    6: .same(proto: "int"),
    7: .same(proto: "double"),
    8: .standard(proto: "collection_bytes"),
    9: .standard(proto: "collection_string"),
    10: .standard(proto: "collection_double"),
    11: .standard(proto: "collection_sint64"),
  ]

  fileprivate class _StorageClass {
    var _data: AzureFunctionsRpcMessages_TypedData.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._data != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._data = .string(v)}
        case 2:
          if _storage._data != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._data = .json(v)}
        case 3:
          if _storage._data != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._data = .bytes(v)}
        case 4:
          if _storage._data != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._data = .stream(v)}
        case 5:
          var v: AzureFunctionsRpcMessages_RpcHttp?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .http(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .http(v)}
        case 6:
          if _storage._data != nil {try decoder.handleConflictingOneOf()}
          var v: Int64?
          try decoder.decodeSingularSInt64Field(value: &v)
          if let v = v {_storage._data = .int(v)}
        case 7:
          if _storage._data != nil {try decoder.handleConflictingOneOf()}
          var v: Double?
          try decoder.decodeSingularDoubleField(value: &v)
          if let v = v {_storage._data = .double(v)}
        case 8:
          var v: AzureFunctionsRpcMessages_CollectionBytes?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .collectionBytes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .collectionBytes(v)}
        case 9:
          var v: AzureFunctionsRpcMessages_CollectionString?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .collectionString(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .collectionString(v)}
        case 10:
          var v: AzureFunctionsRpcMessages_CollectionDouble?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .collectionDouble(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .collectionDouble(v)}
        case 11:
          var v: AzureFunctionsRpcMessages_CollectionSInt64?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .collectionSint64(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .collectionSint64(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._data {
      case .string(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .json(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case .bytes(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      case .stream(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      case .http(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .int(let v)?:
        try visitor.visitSingularSInt64Field(value: v, fieldNumber: 6)
      case .double(let v)?:
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
      case .collectionBytes(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .collectionString(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .collectionDouble(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .collectionSint64(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_TypedData, rhs: AzureFunctionsRpcMessages_TypedData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_CollectionString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollectionString"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.string)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.string.isEmpty {
      try visitor.visitRepeatedStringField(value: self.string, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_CollectionString, rhs: AzureFunctionsRpcMessages_CollectionString) -> Bool {
    if lhs.string != rhs.string {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_CollectionBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollectionBytes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.bytes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bytes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.bytes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_CollectionBytes, rhs: AzureFunctionsRpcMessages_CollectionBytes) -> Bool {
    if lhs.bytes != rhs.bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_CollectionDouble: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollectionDouble"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "double"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedDoubleField(value: &self.double)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.double.isEmpty {
      try visitor.visitPackedDoubleField(value: self.double, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_CollectionDouble, rhs: AzureFunctionsRpcMessages_CollectionDouble) -> Bool {
    if lhs.double != rhs.double {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_CollectionSInt64: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollectionSInt64"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sint64"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedSInt64Field(value: &self.sint64)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sint64.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.sint64, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_CollectionSInt64, rhs: AzureFunctionsRpcMessages_CollectionSInt64) -> Bool {
    if lhs.sint64 != rhs.sint64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_ParameterBinding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParameterBinding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _data: AzureFunctionsRpcMessages_TypedData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_ParameterBinding, rhs: AzureFunctionsRpcMessages_ParameterBinding) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_BindingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BindingInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "type"),
    3: .same(proto: "direction"),
    4: .standard(proto: "data_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularStringField(value: &self.type)
      case 3: try decoder.decodeSingularEnumField(value: &self.direction)
      case 4: try decoder.decodeSingularEnumField(value: &self.dataType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if self.direction != .in {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 3)
    }
    if self.dataType != .undefined {
      try visitor.visitSingularEnumField(value: self.dataType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_BindingInfo, rhs: AzureFunctionsRpcMessages_BindingInfo) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.dataType != rhs.dataType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_BindingInfo.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "in"),
    1: .same(proto: "out"),
    2: .same(proto: "inout"),
  ]
}

extension AzureFunctionsRpcMessages_BindingInfo.DataType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "undefined"),
    1: .same(proto: "string"),
    2: .same(proto: "binary"),
    3: .same(proto: "stream"),
  ]
}

extension AzureFunctionsRpcMessages_RpcLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcLog"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invocation_id"),
    2: .same(proto: "category"),
    3: .same(proto: "level"),
    4: .same(proto: "message"),
    5: .standard(proto: "event_id"),
    6: .same(proto: "exception"),
    7: .same(proto: "properties"),
  ]

  fileprivate class _StorageClass {
    var _invocationID: String = String()
    var _category: String = String()
    var _level: AzureFunctionsRpcMessages_RpcLog.Level = .trace
    var _message: String = String()
    var _eventID: String = String()
    var _exception: AzureFunctionsRpcMessages_RpcException? = nil
    var _properties: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _invocationID = source._invocationID
      _category = source._category
      _level = source._level
      _message = source._message
      _eventID = source._eventID
      _exception = source._exception
      _properties = source._properties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._invocationID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._category)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._level)
        case 4: try decoder.decodeSingularStringField(value: &_storage._message)
        case 5: try decoder.decodeSingularStringField(value: &_storage._eventID)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._exception)
        case 7: try decoder.decodeSingularStringField(value: &_storage._properties)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._invocationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._invocationID, fieldNumber: 1)
      }
      if !_storage._category.isEmpty {
        try visitor.visitSingularStringField(value: _storage._category, fieldNumber: 2)
      }
      if _storage._level != .trace {
        try visitor.visitSingularEnumField(value: _storage._level, fieldNumber: 3)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 4)
      }
      if !_storage._eventID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._eventID, fieldNumber: 5)
      }
      if let v = _storage._exception {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._properties.isEmpty {
        try visitor.visitSingularStringField(value: _storage._properties, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_RpcLog, rhs: AzureFunctionsRpcMessages_RpcLog) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._invocationID != rhs_storage._invocationID {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._level != rhs_storage._level {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._eventID != rhs_storage._eventID {return false}
        if _storage._exception != rhs_storage._exception {return false}
        if _storage._properties != rhs_storage._properties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_RpcLog.Level: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Trace"),
    1: .same(proto: "Debug"),
    2: .same(proto: "Information"),
    3: .same(proto: "Warning"),
    4: .same(proto: "Error"),
    5: .same(proto: "Critical"),
    6: .same(proto: "None"),
  ]
}

extension AzureFunctionsRpcMessages_RpcException: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcException"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "source"),
    1: .standard(proto: "stack_trace"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.stackTrace)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      case 3: try decoder.decodeSingularStringField(value: &self.source)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stackTrace.isEmpty {
      try visitor.visitSingularStringField(value: self.stackTrace, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_RpcException, rhs: AzureFunctionsRpcMessages_RpcException) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.stackTrace != rhs.stackTrace {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_RpcHttpCookie: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcHttpCookie"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .same(proto: "domain"),
    4: .same(proto: "path"),
    5: .same(proto: "expires"),
    6: .same(proto: "secure"),
    7: .standard(proto: "http_only"),
    8: .standard(proto: "same_site"),
    9: .standard(proto: "max_age"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _value: String = String()
    var _domain: AzureFunctionsRpcMessages_NullableString? = nil
    var _path: AzureFunctionsRpcMessages_NullableString? = nil
    var _expires: AzureFunctionsRpcMessages_NullableTimestamp? = nil
    var _secure: AzureFunctionsRpcMessages_NullableBool? = nil
    var _httpOnly: AzureFunctionsRpcMessages_NullableBool? = nil
    var _sameSite: AzureFunctionsRpcMessages_RpcHttpCookie.SameSite = .none
    var _maxAge: AzureFunctionsRpcMessages_NullableDouble? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _value = source._value
      _domain = source._domain
      _path = source._path
      _expires = source._expires
      _secure = source._secure
      _httpOnly = source._httpOnly
      _sameSite = source._sameSite
      _maxAge = source._maxAge
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._value)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._domain)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._path)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._expires)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._secure)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._httpOnly)
        case 8: try decoder.decodeSingularEnumField(value: &_storage._sameSite)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._maxAge)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._value.isEmpty {
        try visitor.visitSingularStringField(value: _storage._value, fieldNumber: 2)
      }
      if let v = _storage._domain {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._path {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._expires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._secure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._httpOnly {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._sameSite != .none {
        try visitor.visitSingularEnumField(value: _storage._sameSite, fieldNumber: 8)
      }
      if let v = _storage._maxAge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_RpcHttpCookie, rhs: AzureFunctionsRpcMessages_RpcHttpCookie) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._expires != rhs_storage._expires {return false}
        if _storage._secure != rhs_storage._secure {return false}
        if _storage._httpOnly != rhs_storage._httpOnly {return false}
        if _storage._sameSite != rhs_storage._sameSite {return false}
        if _storage._maxAge != rhs_storage._maxAge {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AzureFunctionsRpcMessages_RpcHttpCookie.SameSite: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Lax"),
    2: .same(proto: "Strict"),
  ]
}

extension AzureFunctionsRpcMessages_RpcHttp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcHttp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "url"),
    3: .same(proto: "headers"),
    4: .same(proto: "body"),
    10: .same(proto: "params"),
    12: .standard(proto: "status_code"),
    15: .same(proto: "query"),
    16: .standard(proto: "enable_content_negotiation"),
    17: .same(proto: "rawBody"),
    18: .same(proto: "identities"),
    19: .same(proto: "cookies"),
  ]

  fileprivate class _StorageClass {
    var _method: String = String()
    var _url: String = String()
    var _headers: Dictionary<String,String> = [:]
    var _body: AzureFunctionsRpcMessages_TypedData? = nil
    var _params: Dictionary<String,String> = [:]
    var _statusCode: String = String()
    var _query: Dictionary<String,String> = [:]
    var _enableContentNegotiation: Bool = false
    var _rawBody: AzureFunctionsRpcMessages_TypedData? = nil
    var _identities: [AzureFunctionsRpcMessages_RpcClaimsIdentity] = []
    var _cookies: [AzureFunctionsRpcMessages_RpcHttpCookie] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _method = source._method
      _url = source._url
      _headers = source._headers
      _body = source._body
      _params = source._params
      _statusCode = source._statusCode
      _query = source._query
      _enableContentNegotiation = source._enableContentNegotiation
      _rawBody = source._rawBody
      _identities = source._identities
      _cookies = source._cookies
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._method)
        case 2: try decoder.decodeSingularStringField(value: &_storage._url)
        case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._headers)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._body)
        case 10: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._params)
        case 12: try decoder.decodeSingularStringField(value: &_storage._statusCode)
        case 15: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._query)
        case 16: try decoder.decodeSingularBoolField(value: &_storage._enableContentNegotiation)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._rawBody)
        case 18: try decoder.decodeRepeatedMessageField(value: &_storage._identities)
        case 19: try decoder.decodeRepeatedMessageField(value: &_storage._cookies)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 1)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 2)
      }
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._headers, fieldNumber: 3)
      }
      if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._params.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._params, fieldNumber: 10)
      }
      if !_storage._statusCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusCode, fieldNumber: 12)
      }
      if !_storage._query.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._query, fieldNumber: 15)
      }
      if _storage._enableContentNegotiation != false {
        try visitor.visitSingularBoolField(value: _storage._enableContentNegotiation, fieldNumber: 16)
      }
      if let v = _storage._rawBody {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if !_storage._identities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identities, fieldNumber: 18)
      }
      if !_storage._cookies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cookies, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AzureFunctionsRpcMessages_RpcHttp, rhs: AzureFunctionsRpcMessages_RpcHttp) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._method != rhs_storage._method {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._body != rhs_storage._body {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._statusCode != rhs_storage._statusCode {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._enableContentNegotiation != rhs_storage._enableContentNegotiation {return false}
        if _storage._rawBody != rhs_storage._rawBody {return false}
        if _storage._identities != rhs_storage._identities {return false}
        if _storage._cookies != rhs_storage._cookies {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
